/* eslint-disable no-console */
import { FullResult, Reporter, TestCase, TestResult } from '@playwright/test/reporter';
import * as fs from 'fs';
import * as path from 'path';
import { AppConfig } from '../config/AppConfig';
import { analyzeSummary, FailureDetailSummary, TestRunSummary } from './ai-test-analyzer';

class AIReporter implements Reporter {
  private result: TestRunSummary = {
    total: 0,
    passed: 0,
    failed: 0,
    flaky: 0,
    broken: 0,
    skipped: 0,
    failures: [],
  };

  private testFailures: Map<TestCase, FailureDetailSummary> = new Map();

  onTestEnd(test: TestCase, result: TestResult) {
    if (
      result.status === 'failed' ||
      result.status === 'timedOut' ||
      result.status === 'interrupted'
    ) {
      this.handleFailure(test, result);
    } else if (result.status === 'passed') {
      this.result.passed++;
      this.result.total++;
    } else if (result.status === 'skipped') {
      this.result.skipped++;
      this.result.total++;
    }
  }

  private handleFailure(test: TestCase, result: TestResult) {
    // Add placeholder or update existing failure
    const failureSummary: FailureDetailSummary = {
      name: test.title,
      file: test.location.file,
      error: result.error?.message || 'Unknown error',
      trace: result.error?.stack || ''
    };

    // Prefer per-test AI analysis attached from the test layer (baseTest fixture)
    const aiAnalysisAttachment = result.attachments.find((a) => a.name === 'AI Analysis');

    if (aiAnalysisAttachment && aiAnalysisAttachment.body) {
      const analysis = aiAnalysisAttachment.body.toString();
      failureSummary.analysisResult = analysis;
    }

    this.testFailures.set(test, failureSummary);
  }

  async onEnd(result: FullResult) {
    if (result.status === 'passed' && this.testFailures.size === 0) {
      console.log('\n‚úÖ All tests passed. Skipping AI summary.');
      return;
    }

    for (const test of this.testFailures.keys()) {
      const outcome = test.outcome();
      if (outcome === 'flaky') {
        this.result.flaky++;
        this.result.passed--;
      } else if (outcome === 'unexpected') {
        // Find if it was a timeout/interruption or a regular failure
        const lastResult = test.results[test.results.length - 1];
        if (
          lastResult &&
          (lastResult.status === 'timedOut' || lastResult.status === 'interrupted')
        ) {
          this.result.broken++;
          this.result.total++;
        } else {
          this.result.failed++;
          this.result.total++;
        }
      }
    }

    // Populate final failures list (only for those that actually failed in the end or are flaky)
    this.result.failures = Array.from(this.testFailures.values());

    console.log(this.result);

    console.log('\nü§ñ Generating AI Test Summary...');
    const aiAnalysis = await analyzeSummary(this.result);

    const report = this.formatMarkdownReport(this.result, aiAnalysis);

    // Save to file
    const outputPath = path.join(process.cwd(), 'ai-analysis-report.md');
    fs.writeFileSync(outputPath, report);

    // Also log to console for visibility in CI
    console.log('\n=== AI TEST ANALYSIS ===\n');
    console.log(aiAnalysis);
    console.log('\n========================\n');
    console.log(`Report saved to: ${outputPath}`);

    // If running in GitHub Actions, add to Step Summary
    if (AppConfig.github.stepSummary) {
      fs.appendFileSync(AppConfig.github.stepSummary, report);
    }
  }

  private formatMarkdownReport(summary: TestRunSummary, aiAnalysis: string): string {
    const timestamp = new Date().toISOString();

    // Group failures by category
    const categoryCounts: Record<string, number> = {};
    summary.failures.filter((f) => f.analysisResult).forEach((f) => {
      const categoryMatch = f.analysisResult?.match(/\*\*Category\*\*:\s*\[?([^\]\n]+)\]?/);
      const category = categoryMatch ? categoryMatch[1].trim() : 'Unknown';
      categoryCounts[category] = (categoryCounts[category] || 0) + 1;
    });

    const categoryTable = Object.entries(categoryCounts)
      .map(([cat, count]) => `| ${cat} | ${count} |`)
      .join('\n');

    return `# ü§ñ AI Test Analysis Report

> Generated: ${timestamp}

## üìä Summary

### üìà Metrics
| Metric | Value |
|--------|-------|
| Total Tests | ${summary.total} |
| ‚úÖ Passed | ${summary.passed} |
| ‚ùå Failed | ${summary.failed} |
| üîÑ Flaky | ${summary.flaky} |
| üíî Broken | ${summary.broken} |
| ‚è≠Ô∏è Skipped | ${summary.skipped} |

### üè∑Ô∏è Failures by Category
| Category | Count |
|----------|-------|
${categoryTable || '| No categorized failures | 0 |'}

---

${aiAnalysis}

---
*This report was generated by AI.*
`;
  }
}

export default AIReporter;
